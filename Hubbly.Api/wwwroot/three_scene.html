<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hubbly 3D Avatars</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }

        /* Индикатор загрузки */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: Arial, sans-serif;
        }

        .loadingSpinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #8b5cf6;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <!-- Canvas для Three.js -->
    <canvas id="renderCanvas"></canvas>

    <script type="module">
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js";
        import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js";
        import * as TWEEN from "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js";

        const CONFIG = {
            SERVER_BASE_URL: "http://89.169.46.33:5000/",
            SLOT_COUNT: 10,
            SLOT_SPACING: 1.5,
            CAMERA_HEIGHT: 1.1,        // Смотрим в центр аватара
            CAMERA_DISTANCE: 1.5,
            SCROLL_SENSITIVITY: 0.005,
            HIGHLIGHT_COLOR: 0x8b5cf6,
            DEFAULT_COLOR: 0x3b82f6,
            MODEL_SCALE: 1.0,
            AVATAR_HEIGHT: 1.8,         // Высота аватара
            AVATAR_CENTER_Y: 1.1,       // Центр аватара по Y
            ANIMATIONS: {
                idle: 'idle.glb',
                clap: 'clapping.glb'
            }
        };

        let scene, camera, renderer;
        let avatarManager;
        let cameraController;
        let isInitialized = false;
        let clock = new THREE.Clock();

        class Avatar {
            constructor(userId, nickname, gender, isCurrentUser = false) {
                this.userId = userId;
                this.nickname = nickname;
                this.gender = gender;
                this.isCurrentUser = isCurrentUser;
                this.mesh = null;
                this.mixer = null;
                this.actions = new Map();
                this.currentAction = null;
                this.animationClips = new Map();
                this.slotIndex = -1;
                this.isLoaded = false;
                this.usingFallback = false;

                this.createPlaceholder();
            }

            createPlaceholder() {
                const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.4);
                const color = this.isCurrentUser ? CONFIG.HIGHLIGHT_COLOR : CONFIG.DEFAULT_COLOR;
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 30,
                    transparent: true,
                    opacity: 0.8
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.userData.avatar = this;
                this.mesh.userData.avatarId = this.userId;
                this.mesh.userData.nickname = this.nickname;
                this.mesh.name = `avatar_${this.userId}`;

                // Тень
                const shadowGeometry = new THREE.CircleGeometry(0.6, 32);
                const shadowMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 });
                const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.y = -0.9;
                shadow.userData.avatar = this;
                shadow.userData.avatarId = this.userId;
                shadow.userData.nickname = this.nickname;
                this.mesh.add(shadow);
            }

            disposeMesh(mesh) {
                if (!mesh) return;
                mesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                    if (child.texture) child.texture.dispose();
                });
            }

            async loadModel() {
                if (this.isLoaded) return;

                const parent = this.mesh.parent;
                const currentX = this.mesh.position.x;

                try {
                    const newMesh = await this.loadGLBModel();
                    this.usingFallback = false;

                    if (newMesh) {
                        if (this.mesh && parent) {
                            parent.remove(this.mesh);
                            this.disposeMesh(this.mesh);
                        }

                        this.mesh = newMesh;

                        // ✅ СНАЧАЛА ставим позицию
                        this.mesh.position.set(currentX, 0.2, 0);
                        console.log(`[POSITION] После set:`, this.mesh.position.clone());

                        // ✅ Проставляем userData
                        this.mesh.userData.avatar = this;
                        this.mesh.userData.avatarId = this.userId;
                        this.mesh.userData.nickname = this.nickname;

                        this.mesh.traverse((child) => {
                            if (child.isMesh) {
                                child.userData.avatar = this;
                                child.userData.avatarId = this.userId;
                                child.userData.nickname = this.nickname;
                                child.visible = true;

                                // ✅ Логируем позиции детей
                                console.log(`[CHILD] ${child.name || 'mesh'} position:`, child.position.clone());
                            }
                        });

                        // ✅ ФИНАЛЬНАЯ ПОЗИЦИЯ
                        console.log(`[FINAL] mesh position:`, this.mesh.position.clone());

                        this.mixer = new THREE.AnimationMixer(this.mesh);

                        if (parent) {
                            parent.add(this.mesh);
                        }

                        await this.loadAndPlayIdleAnimation();
                    }

                    this.isLoaded = true;

                } catch (error) {
                    console.error(`[FATAL MODEL] Failed to process model for ${this.nickname}:`, error);
                    this.isLoaded = true;
                }
            }

            loadGLBModel() {
                return new Promise((resolve, reject) => {
                    let modelPath;

                    if (this.gender === 'male') {
                        modelPath = `${CONFIG.SERVER_BASE_URL}avatars/male_base.glb`;
                    } else if (this.gender === 'female') {
                        modelPath = `${CONFIG.SERVER_BASE_URL}avatars/female_base.glb`;
                    } else {
                        return reject(new Error("Unknown gender specified."));
                    }

                    const loader = new GLTFLoader();

                    const onLoad = (gltf) => {
                        const model = gltf.scene;
                        model.scale.set(5, 5, 5);
                        model.name = `glb_avatar_${this.userId}`;

                        model.traverse((child) => {
                            if (child.isMesh && child.material) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material.transparent = true;
                                child.material.opacity = 0;
                                new TWEEN.Tween(child.material)
                                    .to({ opacity: 1 }, 500)
                                    .delay(100)
                                    .start();
                            }
                        });

                        resolve(model);
                    };

                    const onError = (error) => {
                        console.error('[MODEL] GLTFLoader ERROR:', error);
                        reject(error);
                    };

                    loader.load(modelPath, onLoad, null, onError);
                });
            }

            async loadAndPlayIdleAnimation() {
                try {
                    const idleAnimation = await this.loadAnimation('idle');

                    if (idleAnimation) {
                        this.animationClips.set('idle', idleAnimation);
                        const action = this.mixer.clipAction(idleAnimation);
                        this.actions.set('idle', action);
                        this.playAnimation('idle', true, 0.5);
                    }
                } catch (error) {
                    console.warn(`[ANIM] Could not load idle animation for ${this.nickname}:`, error.message);
                }
            }

            async loadAnimation(animationName) {
                return new Promise((resolve, reject) => {
                    let animationPath;

                    if (this.gender === 'male') {
                        animationPath = `${CONFIG.SERVER_BASE_URL}animations/male_${CONFIG.ANIMATIONS[animationName]}`;
                    } else if (this.gender === 'female') {
                        animationPath = `${CONFIG.SERVER_BASE_URL}animations/female_${CONFIG.ANIMATIONS[animationName]}`;
                    } else {
                        return reject(new Error("Unknown gender for animation"));
                    }

                    const loader = new GLTFLoader();

                    const onLoad = (gltf) => {
                        if (gltf.animations && gltf.animations.length > 0) {
                            const animation = gltf.animations[0];
                            animation.name = animationName;
                            resolve(animation);
                        } else {
                            reject(new Error(`No animations found in ${animationPath}`));
                        }
                    };

                    const onError = (error) => {
                        console.error(`[ANIM] Failed to load animation "${animationName}":`, error);
                        reject(error);
                    };

                    loader.load(animationPath, onLoad, null, onError);
                });
            }

            async playAnimation(animationName, loop = true, fadeDuration = 0.3) {
                if (!this.actions.has(animationName)) {
                    try {
                        const animationClip = await this.loadAnimation(animationName);
                        if (animationClip) {
                            this.animationClips.set(animationName, animationClip);
                            const action = this.mixer.clipAction(animationClip);
                            this.actions.set(animationName, action);
                        }
                    } catch (error) {
                        console.warn(`[ANIM] Failed to load animation "${animationName}" for ${this.nickname}:`, error);
                        return false;
                    }
                }

                const action = this.actions.get(animationName);
                if (!action) {
                    console.warn(`[ANIM] Animation "${animationName}" not found for ${this.nickname}`);
                    return false;
                }

                if (this.currentAction) {
                    this.currentAction.fadeOut(fadeDuration);
                }

                action.reset();
                action.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
                action.clampWhenFinished = true;
                action.fadeIn(fadeDuration).play();

                this.currentAction = action;
                return true;
            }

            stopAnimation(fadeDuration = 0.3) {
                if (this.currentAction) {
                    this.currentAction.fadeOut(fadeDuration);
                    this.currentAction = null;
                }
            }

            setSlot(index) {
                this.slotIndex = index;
                this.updatePosition();
            }

            updatePosition() {
                if (this.slotIndex < 0 || !this.mesh) return;
                const xPos = this.slotIndex * CONFIG.SLOT_SPACING;

                if (this.isLoaded && !this.usingFallback) {
                    // ✅ GLB: pivot в ногах - ставим ноги на 0.2
                    this.mesh.position.set(xPos, 0.2, 0);
                } else {
                    this.mesh.position.set(xPos, CONFIG.AVATAR_CENTER_Y, 0);
                }
            }

            update(deltaTime) {
                if (this.mixer) {
                    this.mixer.update(deltaTime);
                }
            }

            dispose() {
                if (this.mixer) {
                    this.mixer.stopAllAction();
                    this.mixer = null;
                }

                this.actions.clear();
                this.animationClips.clear();
                this.currentAction = null;

                if (this.mesh) {
                    if (this.mesh.parent) {
                        this.mesh.parent.remove(this.mesh);
                    }
                    this.disposeMesh(this.mesh);
                }
                this.mesh = null;
            }
        }

        class AvatarManager {
            constructor() {
                this.avatars = new Map();
                this.availableSlots = Array.from({ length: CONFIG.SLOT_COUNT }, (_, i) => i);
            }

            addAvatar(userId, nickname, gender, isCurrentUser = false) {
                if (this.avatars.has(userId)) return false;
                if (this.availableSlots.length === 0) {
                    console.error('No available slots');
                    return false;
                }

                const slotIndex = this.availableSlots.shift();
                const avatar = new Avatar(userId, nickname, gender, isCurrentUser);
                avatar.setSlot(slotIndex);

                this.avatars.set(userId, avatar);
                scene.add(avatar.mesh);

                setTimeout(() => {
                    avatar.loadModel();
                }, 300 + (this.getAvatarCount() * 200));

                // ✅ ВАЖНО: обновляем кликабельные объекты
                if (window.__updateClickableObjects) {
                    setTimeout(() => window.__updateClickableObjects(), 500);
                }

                return true;
            }

            removeAvatar(userId) {
                const avatar = this.avatars.get(userId);
                if (!avatar) return false;

                this.availableSlots.push(avatar.slotIndex);
                this.availableSlots.sort((a, b) => a - b);

                avatar.dispose();
                this.avatars.delete(userId);

                // ✅ ВАЖНО: обновляем кликабельные объекты
                if (window.__updateClickableObjects) {
                    setTimeout(() => window.__updateClickableObjects(), 100);
                }

                return true;
            }

            getAvatarCount() {
                return this.avatars.size;
            }

            getAvatar(userId) {
                return this.avatars.get(userId);
            }

            getAvatars() {
                return Array.from(this.avatars.values());
            }

            clearAll() {
                for (const avatar of this.avatars.values()) {
                    avatar.dispose();
                }
                this.avatars.clear();
                this.availableSlots = Array.from({ length: CONFIG.SLOT_COUNT }, (_, i) => i);
            }

            updateAvatars(deltaTime) {
                for (const avatar of this.avatars.values()) {
                    avatar.update(deltaTime);
                }
            }

            playAvatarAnimation(userId, animationName = 'idle', loop = true) {
                const avatar = this.avatars.get(userId);
                if (!avatar) return false;
                return avatar.playAnimation(animationName, loop);
            }

            stopAvatarAnimation(userId) {
                const avatar = this.avatars.get(userId);
                if (!avatar) return false;
                avatar.stopAnimation();
                return true;
            }

            playAllAnimation(animationName = 'idle', loop = true) {
                let successCount = 0;
                for (const avatar of this.avatars.values()) {
                    if (avatar.playAnimation(animationName, loop)) {
                        successCount++;
                    }
                }
                return successCount;
            }

            stopAllAnimations() {
                let successCount = 0;
                for (const avatar of this.avatars.values()) {
                    avatar.stopAnimation();
                    successCount++;
                }
                return successCount;
            }
        }

        class CameraController {
            constructor(camera) {
                this.camera = camera;
                this.targetX = 0;
                this.isDragging = false;
                this.startX = 0;
                this.currentX = 0;
                this.initialized = false;

                this.setupCamera();
                this.setupEventListeners();
            }

            setupCamera() {
                const aspect = window.innerWidth / window.innerHeight;

                // ✅ Расчёт фрустума: аватар высотой 1.8 занимает 75% экрана
                // frustumSize = высота_аватара / желаемый_процент = 1.8 / 0.75 = 2.4
                const frustumSize = 2.4;

                this.camera.left = -frustumSize * aspect / 2;
                this.camera.right = frustumSize * aspect / 2;
                this.camera.top = frustumSize / 2;
                this.camera.bottom = -frustumSize / 2;
                this.camera.near = 0.1;
                this.camera.far = 1000;
                this.camera.updateProjectionMatrix();

                // ✅ Смотрим в центр аватара (Y = 1.1)
                this.camera.position.set(0, CONFIG.AVATAR_CENTER_Y, CONFIG.CAMERA_DISTANCE);
                this.camera.lookAt(0, CONFIG.AVATAR_CENTER_Y, 0);
            }

            setupEventListeners() {
                const canvas = document.getElementById('renderCanvas');
                canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                canvas.addEventListener('mouseleave', this.onMouseUp.bind(this));
                canvas.addEventListener('touchstart', this.onTouchStart.bind(this), { passive: false });
                canvas.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: false });
                canvas.addEventListener('touchend', this.onTouchEnd.bind(this));
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }

            onMouseDown(event) {
                event.preventDefault();
                this.isDragging = true;
                this.startX = event.clientX;
                this.currentX = this.camera.position.x;
            }

            onMouseMove(event) {
                if (!this.isDragging) return;
                event.preventDefault();
                const deltaX = event.clientX - this.startX;
                this.targetX = this.currentX - deltaX * CONFIG.SCROLL_SENSITIVITY;
                this.updateCameraPosition();
            }

            onMouseUp() {
                if (!this.isDragging) return;
                this.isDragging = false;
                this.snapToNearestSlot();
            }

            onTouchStart(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    this.isDragging = true;
                    this.startX = event.touches[0].clientX;
                    this.currentX = this.camera.position.x;
                }
            }

            onTouchMove(event) {
                if (!this.isDragging || event.touches.length !== 1) return;
                event.preventDefault();
                const deltaX = event.touches[0].clientX - this.startX;
                this.targetX = this.currentX - deltaX * CONFIG.SCROLL_SENSITIVITY;
                this.updateCameraPosition();
            }

            onTouchEnd() {
                this.isDragging = false;
                this.snapToNearestSlot();
            }

            onWindowResize() {
                this.setupCamera();
                if (renderer) {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            updateCameraPosition() {
                const lerpFactor = 0.2;
                const dx = this.targetX - this.camera.position.x;
                this.camera.position.x += dx * lerpFactor;
            }

            snapToNearestSlot() {
                const targetSlot = Math.round(this.camera.position.x / CONFIG.SLOT_SPACING);
                const maxSlots = Math.floor(CONFIG.SLOT_COUNT / 2);
                const minSlot = -maxSlots;
                this.targetX = Math.max(minSlot, Math.min(maxSlots, targetSlot)) * CONFIG.SLOT_SPACING;
            }

            update() {
                if (!this.isDragging) {
                    this.updateCameraPosition();
                }

                if (!this.initialized && window.currentUserId) {
                    const myAvatar = avatarManager?.getAvatar(window.currentUserId);
                    if (myAvatar && myAvatar.slotIndex !== undefined) {
                        this.targetX = myAvatar.slotIndex * CONFIG.SLOT_SPACING;
                        this.initialized = true;
                        console.log(`🎥 Camera centered on slot ${myAvatar.slotIndex}`);
                    }
                }
            }
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);

            camera = new THREE.OrthographicCamera();

            const canvas = document.getElementById('renderCanvas');
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                powerPreference: "high-performance"
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            setupLighting();
            avatarManager = new AvatarManager();
            cameraController = new CameraController(camera);

            // ✅ Удаляем statusBar полностью
            const existingStatusBar = document.getElementById('statusBar');
            if (existingStatusBar) {
                existingStatusBar.remove();
            }

            setupRaycaster();

            setTimeout(() => {
                isInitialized = true;
                console.log('✅ Three.js initialized successfully');

                // Убираем loadingOverlay
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
            }, 1000);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            // Пол убираем совсем — тени падают на невидимую плоскость
            // или можно оставить прозрачный пол для теней
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();

            const deltaTime = clock.getDelta();

            if (avatarManager) {
                avatarManager.updateAvatars(deltaTime);
            }

            if (cameraController) {
                cameraController.update();
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        let handleClick;
        let clickableObjects = [];
        let lastClickTime = 0;
        const clickDelay = 300;

        function setupRaycaster() {
            const canvas = document.getElementById('renderCanvas');

            function updateClickableObjects() {
                window.clickableObjects.length = 0;
                scene.traverse(obj => {
                    if (obj.isMesh && obj.userData.avatarId) {
                        window.clickableObjects.push(obj);
                    }
                });
            }

            function findAvatarData(obj) {
                while (obj) {
                    if (obj.userData.avatarId) return obj.userData.avatarId;
                    if (obj.userData.avatar?.userId) return obj.userData.avatar.userId;
                    obj = obj.parent;
                }
                return null;
            }

            window.__updateClickableObjects = updateClickableObjects;
            window.clickableObjects = [];
            updateClickableObjects();
            setInterval(updateClickableObjects, 3000);

            window.handleClick = function (event) {
                const currentTime = Date.now();
                if (currentTime - lastClickTime < clickDelay) return;
                lastClickTime = currentTime;

                const rect = canvas.getBoundingClientRect();
                const mouse = new THREE.Vector2();

                // Нормализуем координаты относительно canvas, а не окна!
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                console.log(`🎯 Mouse normalized:`, mouse.x, mouse.y);

                // 2. Для OrthographicCamera: луч идет ПАРАЛЛЕЛЬНО из точки клика
                const raycaster = new THREE.Raycaster();

                // Устанавливаем луч из координат мыши в мировом пространстве
                raycaster.setFromCamera(mouse, camera);

                // 🔥🔥🔥 КРИТИЧЕСКИ ВАЖНО: ОБНОВЛЯЕМ МАТРИЦУ КАМЕРЫ!
                camera.updateMatrixWorld(true);

                // 3. Визуализация
                const arrow = new THREE.ArrowHelper(
                    raycaster.ray.direction,
                    raycaster.ray.origin,
                    10,
                    0xff0000
                );
                scene.add(arrow);
                setTimeout(() => scene.remove(arrow), 500);

                // 4. Проверяем пересечения
                const intersects = raycaster.intersectObjects(window.clickableObjects, true);
                console.log(`🎯 Intersects: ${intersects.length}`);

                if (intersects.length > 0) {
                    const userId = findAvatarData(intersects[0].object);
                    if (userId) {
                        console.log(`✅ Клик по аватару: ${userId}`);

                        const message = JSON.stringify({
                            type: 'avatar_clicked',
                            userId: userId
                        });

                        if (window.hubblyBridge) {
                            window.hubblyBridge.postMessage(message);
                            console.log('✅ Sent via hubblyBridge');
                        }
                    }
                }
            };

            canvas.addEventListener('click', window.handleClick);
            canvas.addEventListener('touchend', (event) => {
                if (event.touches.length === 0) {
                    const touch = event.changedTouches[0];
                    const mouseEvent = new MouseEvent('click', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    window.handleClick(mouseEvent);
                }
            });

            window.debugRaycast = function (x, y) {
                if (!canvas) canvas = document.getElementById('renderCanvas');

                const rect = canvas.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((y - rect.top) / rect.height) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                camera.updateMatrixWorld(true);

                console.log('========== ДЕБАГ РЕЖИМ ==========');
                console.log('1. Координаты мыши:', x, y);
                console.log('2. Mouse normalized:', mouse.x, mouse.y);
                console.log('3. Camera position:', camera.position.clone());
                console.log('4. Camera matrix:', camera.matrixWorld.clone());
                console.log('5. Ray origin:', raycaster.ray.origin.clone());
                console.log('6. Ray direction:', raycaster.ray.direction.clone());

                // Визуализация
                const arrow = new THREE.ArrowHelper(
                    raycaster.ray.direction,
                    raycaster.ray.origin,
                    10,
                    0xff0000
                );
                scene.add(arrow);
                setTimeout(() => scene.remove(arrow), 3000);

                // Информация об аватарах
                console.log('7. Всего аватаров:', avatarManager?.getAvatars().length);
                window.clickableObjects.forEach((obj, i) => {
                    const worldPos = obj.getWorldPosition(new THREE.Vector3());
                    const box = new THREE.Box3().setFromObject(obj);
                    console.log(`   Аватар ${i}:`, {
                        id: obj.userData.avatarId,
                        localPos: obj.position.clone(),
                        worldPos: worldPos,
                        boundingBox: box,
                        bounds: {
                            min: box.min.clone(),
                            max: box.max.clone()
                        }
                    });
                });

                // Проверка пересечений
                const intersects = raycaster.intersectObjects(window.clickableObjects, true);
                console.log('8. Пересечений:', intersects.length);

                if (intersects.length > 0) {
                    console.log('9. Первое пересечение:', {
                        distance: intersects[0].distance,
                        point: intersects[0].point.clone(),
                        object: intersects[0].object.userData.avatarId
                    });
                } else {
                    // Проверяем пересечение с плоскостью на разных высотах
                    [0, 0.2, 0.5, 1.1, 1.5, 2.0].forEach(y => {
                        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -y);
                        const point = new THREE.Vector3();
                        if (raycaster.ray.intersectPlane(plane, point)) {
                            console.log(`   Пересечение с плоскостью Y=${y}:`, point.clone());
                        }
                    });
                }
                console.log('================================');
            };

            // Для удобства - клик по координатам
            window.clickAt = function (x, y) {
                window.debugRaycast(x, y);
            };

            console.log('✅ Raycaster setup complete');
        }

        window.hubbly3d = {
            isReady: function () {
                return typeof THREE !== 'undefined' && scene && isInitialized;
            },
            addAvatar: function (userId, nickname, gender, isCurrentUser = false) {
                if (!isInitialized || !avatarManager) return false;

                if (isCurrentUser) {
                    window.currentUserId = userId;
                    console.log(`👑 Current user set: ${userId}`);
                }

                return avatarManager.addAvatar(userId, nickname, gender, isCurrentUser);
            },
            removeAvatar: function (userId) {
                if (!isInitialized || !avatarManager) return false;
                return avatarManager.removeAvatar(userId);
            },
            clearAvatars: function () {
                if (!isInitialized || !avatarManager) return false;
                avatarManager.clearAll();
                return true;
            },
            getAvatarCount: function () {
                if (!avatarManager) return 0;
                return avatarManager.getAvatarCount();
            },
            getAvatars: function () {
                if (!avatarManager) return [];
                return avatarManager.getAvatars().map(a => ({
                    userId: a.userId,
                    nickname: a.nickname,
                    gender: a.gender,
                    isLoaded: a.isLoaded
                }));
            },
            playAnimation: function (userId, animationName = 'idle', loop = true) {
                if (!avatarManager) return false;
                return avatarManager.playAvatarAnimation(userId, animationName, loop);
            },
            stopAnimation: function (userId) {
                if (!avatarManager) return false;
                return avatarManager.stopAvatarAnimation(userId);
            },
            playAllAnimation: function (animationName = 'idle', loop = true) {
                if (!avatarManager) return 0;
                return avatarManager.playAllAnimation(animationName, loop);
            },
            stopAllAnimations: function () {
                if (!avatarManager) return 0;
                return avatarManager.stopAllAnimations();
            }
        };

        document.addEventListener('DOMContentLoaded', function () {
            function isWebGLAvailable() {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext &&
                        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch (e) {
                    return false;
                }
            }

            if (!isWebGLAvailable()) {
                document.getElementById('loadingOverlay').innerHTML =
                    '<div style="color: #ef4444; text-align: center; padding: 20px;">WebGL Not Supported</div>';
                return;
            }

            initThreeJS();
            animate();
        });
    </script>
</body>
</html>