<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hubbly 3D Avatars</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: Arial, sans-serif;
        }

        .loadingSpinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #8b5cf6;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.121.1';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';
        import * as TWEEN from 'https://cdn.skypack.dev/@tweenjs/tween.js@18.6.4';

        const CONFIG = {
            SERVER_BASE_URL: getServerBaseUrl(),
            SLOT_SPACING: 2.0,
            CAMERA_DISTANCE: 2.5,
            SCROLL_SENSITIVITY: 0.005,
            HIGHLIGHT_COLOR: 0x8b5cf6,
            DEFAULT_COLOR: 0x3b82f6,
            MODEL_SCALE: 1.8,
            AVATAR_FOOT_Y: -0.6,
            VISIBLE_RANGE: 3,
            ANIMATIONS: {
                idle: 'idle.glb',
                clap: 'clapping.glb',
                wave: 'waving.glb'
            }
        };

        function getServerBaseUrl() {
            // 1. Try URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            const serverParam = urlParams.get('server');
            if (serverParam) {
                return serverParam.endsWith('/') ? serverParam : serverParam + '/';
            }
            
            // 2. Try meta tag
            const metaTag = document.querySelector('meta[name="server-url"]');
            if (metaTag && metaTag.content) {
                return metaTag.content.endsWith('/') ? metaTag.content : metaTag.content + '/';
            }
            
            // 3. Use current origin (default)
            const origin = window.location.origin;
            return origin.endsWith('/') ? origin : origin + '/';
        }

        let scene, camera, renderer;
        let avatarManager;
        let cameraController;
        let isInitialized = false;
        let clock = new THREE.Clock();
        let updateInterval = null;

        class Avatar {
            constructor(userId, nickname, gender, isCurrentUser = false) {
                this.userId = userId;
                this.nickname = nickname;
                this.gender = gender;
                this.isCurrentUser = isCurrentUser;
                this.group = null;
                this.collider = null;
                this.mixer = null;
                this.actions = new Map();
                this.currentAction = null;
                this.animationClips = new Map();
                this.slotIndex = -1;
                this.isLoaded = false;

                this.createPlaceholder();
            }

            createPlaceholder() {
                this.group = new THREE.Group();

                // Visual part (transparent cube)
                const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.4);
                const color = this.isCurrentUser ? CONFIG.HIGHLIGHT_COLOR : CONFIG.DEFAULT_COLOR;
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 30,
                    transparent: true,
                    opacity: 0.8
                });

                const body = new THREE.Mesh(geometry, material);
                body.castShadow = true;
                body.receiveShadow = true;
                body.position.y = 0.9;
                this.group.add(body);

                const headGeo = new THREE.SphereGeometry(0.25);
                const headMat = new THREE.MeshPhongMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 1.8;
                head.castShadow = true;
                head.receiveShadow = true;
                this.group.add(head);

                const shadowGeo = new THREE.CircleGeometry(0.6, 32);
                const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.y = 0.01;
                this.group.add(shadow);

                const boxGeo = new THREE.BoxGeometry(0.8, 1.8, 0.4);
                const boxMat = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.0
                });

                this.collider = new THREE.Mesh(boxGeo, boxMat);
                this.collider.position.y = 0.9;

                this.collider.userData = {
                    avatarId: this.userId,
                    nickname: this.nickname,
                    isCurrentUser: this.isCurrentUser,
                    isCollider: true
                };

                this.group.add(this.collider);

                this.group.userData = {
                    avatarId: this.userId,
                    nickname: this.nickname,
                    isCurrentUser: this.isCurrentUser
                };
            }

            disposeMesh(mesh) {
                if (!mesh) return;
                mesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                    if (child.texture) child.texture.dispose();
                });
            }

            async loadModel() {
                if (this.isLoaded) return;

                const parent = this.group ? this.group.parent : null;
                const currentX = this.xPosition; // Use saved position
                const oldCollider = this.collider;

                try {
                    const newModel = await this.loadGLBModel();

                    if (newModel) {
                        if (this.group && parent) {
                            parent.remove(this.group);
                        }

                        this.group = newModel;
                        this.group.position.set(currentX, CONFIG.AVATAR_FOOT_Y, 0); // Use currentX
                        this.group.scale.set(CONFIG.MODEL_SCALE, CONFIG.MODEL_SCALE, CONFIG.MODEL_SCALE);

                        if (oldCollider) {
                            if (oldCollider.parent) {
                                oldCollider.parent.remove(oldCollider);
                            }

                            oldCollider.userData = {
                                avatarId: this.userId,
                                nickname: this.nickname,
                                isCurrentUser: this.isCurrentUser,
                                isCollider: true
                            };

                            this.group.add(oldCollider);
                            this.collider = oldCollider;
                        }

                        this.group.userData = {
                            avatarId: this.userId,
                            nickname: this.nickname,
                            isCurrentUser: this.isCurrentUser
                        };

                        this.mixer = new THREE.AnimationMixer(this.group);

                        if (parent) {
                            parent.add(this.group);
                        }

                        await this.loadAndPlayIdleAnimation();
                    }

                    this.isLoaded = true;

                } catch (error) {
                    console.error(`[MODEL] Failed to load model for ${this.nickname}:`, error);
                    this.isLoaded = true;
                }
            }

            loadGLBModel() {
                return new Promise((resolve, reject) => {
                    let modelPath = this.gender === 'male'
                        ? `${CONFIG.SERVER_BASE_URL}avatars/male_base.glb`
                        : `${CONFIG.SERVER_BASE_URL}avatars/female_base.glb`;

                    new GLTFLoader().load(modelPath,
                        (gltf) => {
                            const model = gltf.scene;
                            model.name = `glb_avatar_${this.userId}`;

                            model.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });

                            resolve(model);
                        },
                        null,
                        (error) => reject(error)
                    );
                });
            }

            async loadAndPlayIdleAnimation() {
                try {
                    const idleAnimation = await this.loadAnimation('idle');
                    if (idleAnimation && this.mixer) {
                        const action = this.mixer.clipAction(idleAnimation);
                        action.setLoop(THREE.LoopRepeat, Infinity); // idle should loop
                        this.actions.set('idle', action);
                        action.play();
                        this.currentAction = action;
                    }
                } catch (error) {
                    console.warn(`[ANIM] Could not load idle animation:`, error.message);
                }
            }

            async loadAnimation(animationName) {
                return new Promise((resolve, reject) => {
                    // Form correct filename based on gender
                    let animationFile;

                    if (animationName === 'idle') {
                        animationFile = this.gender === 'male' ? 'male_idle.glb' : 'female_idle.glb';
                    } else if (animationName === 'clap') {
                        animationFile = this.gender === 'male' ? 'male_clapping.glb' : 'female_clapping.glb';
                    } else if (animationName === 'wave') {
                        animationFile = this.gender === 'male' ? 'male_waving.glb' : 'female_waving.glb';
                    } else {
                        // For other animations (if added)
                        animationFile = `${this.gender}_${animationName}.glb`;
                    }

                    const animationPath = `${CONFIG.SERVER_BASE_URL}animations/${animationFile}`;

                    console.log(`Loading animation: ${animationPath}`);

                    new GLTFLoader().load(animationPath,
                        (gltf) => {
                            if (gltf.animations?.length > 0) {
                                resolve(gltf.animations[0]);
                            } else {
                                reject(new Error(`No animations found in ${animationFile}`));
                            }
                        },
                        null,
                        (error) => reject(error)
                    );
                });
            }

            async playAnimation(animationName, loop = false, fadeDuration = 0.3) {
                if (!this.mixer) return false;

                // Load animation if it doesn't exist
                if (!this.actions.has(animationName)) {
                    try {
                        const clip = await this.loadAnimation(animationName);
                        if (clip) {
                            const action = this.mixer.clipAction(clip);
                            this.actions.set(animationName, action);
                        }
                    } catch (error) {
                        console.warn(`Failed to load animation ${animationName} for ${this.nickname}:`, error);
                        return false;
                    }
                }

                const action = this.actions.get(animationName);
                if (!action) return false;

                // Stop current animation
                if (this.currentAction) {
                    this.currentAction.fadeOut(fadeDuration);
                }

                // Configure new animation
                action.reset();

                if (loop) {
                    // Looping animation (idle)
                    action.setLoop(THREE.LoopRepeat, Infinity);
                    action.clampWhenFinished = false;
                } else {
                    // One-time animation (clap)
                    action.setLoop(THREE.LoopOnce, 1);
                    action.clampWhenFinished = false;

                    // Get animation duration
                    if (action.getClip()) {
                        const duration = action.getClip().duration * 1000; // in milliseconds

                        // Remove previous timer if exists
                        if (this._returnToIdleTimer) {
                            clearTimeout(this._returnToIdleTimer);
                        }

                        // Set timer to return to idle
                        this._returnToIdleTimer = setTimeout(() => {
                            if (this.mixer && this.currentAction === action) {
                                console.log(`${this.nickname} finished ${animationName}, returning to idle`);
                                this.playAnimation('idle', true, fadeDuration);
                            }
                            this._returnToIdleTimer = null;
                        }, duration - 50); // Return slightly earlier for smoothness
                    }
                }

                action.fadeIn(fadeDuration).play();
                this.currentAction = action;

                return true;
            }

            async ensureIdleAnimation() {
                if (!this.actions.has('idle')) {
                    try {
                        await this.loadAndPlayIdleAnimation();
                    } catch (error) {
                        console.warn('Failed to load idle animation:', error);
                    }
                }
            }

            setPosition(x) {
                this.xPosition = x;
                if (this.group) {
                    this.group.position.set(x, CONFIG.AVATAR_FOOT_Y, 0);
                }
            }

            setSlot(index) {
                this.slotIndex = index;
                const xPos = (index - 25) * CONFIG.SLOT_SPACING;
                this.setPosition(xPos);
            }

            updatePosition() {
                if (this.slotIndex >= 0) {
                    const xPos = (this.slotIndex - 25) * CONFIG.SLOT_SPACING;
                    this.setPosition(xPos);
                } else {
                    this.setPosition(this.xPosition);
                }
            }

            update(deltaTime) {
                if (this.mixer) {
                    this.mixer.update(deltaTime);
                }
            }

            dispose() {
                if (this._returnToIdleTimer) {
                    clearTimeout(this._returnToIdleTimer);
                    this._returnToIdleTimer = null;
                }

                if (this.mixer) {
                    this.mixer.stopAllAction();
                    if (this.group) {
                        this.mixer.uncacheRoot(this.group);
                    }
                    this.mixer = null;
                }

                this.actions.clear();
                this.animationClips.clear();
                this.currentAction = null;

                if (this.group) {
                    // Clear geometry and materials
                    this.group.traverse((obj) => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(m => m.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    });

                    if (this.group.parent) {
                        this.group.parent.remove(this.group);
                    }
                }

                this.group = null;
                this.collider = null;
            }
        }

        class AvatarManager {
            constructor() {
                this.avatars = new Map();
                this.positions = new Map(); // userId -> { slot, x }
                this.availableSlots = [];

                // Create slots for 50 people (from 0 to 49)
                for (let i = 0; i < 50; i++) {
                    this.availableSlots.push(i);
                }
            }

            addAvatar(userId, nickname, gender, isCurrentUser = false) {
                if (this.avatars.has(userId)) {
                    console.log(`Avatar ${userId} already exists`);
                    return false;
                }

                if (this.availableSlots.length === 0) {
                    console.warn('No available slots');
                    return false;
                }

                const slotIndex = this.availableSlots.shift();

                // Calculate position: from -49 to 0? No, better symmetrically from -24.5 to 24.5
                // So center is between slots 24 and 25
                const xPos = (slotIndex - 24.5) * CONFIG.SLOT_SPACING;

                const avatar = new Avatar(userId, nickname, gender, isCurrentUser);
                avatar.setPosition(xPos);
                avatar.slotIndex = slotIndex; // Save index

                this.avatars.set(userId, avatar);
                this.positions.set(userId, { slot: slotIndex, x: xPos });

                scene.add(avatar.group);

                // Load model immediately (parallel loading)
                avatar.loadModel();

                if (window.__updateClickableObjects) {
                    window.__updateClickableObjects();
                }

                if (cameraController) {
                    cameraController.updateBounds();
                }

                return true;
            }

            removeAvatar(userId) {
                const avatar = this.avatars.get(userId);
                if (!avatar) return false;

                const position = this.positions.get(userId);
                if (position) {
                    this.availableSlots.push(position.slot);
                    this.availableSlots.sort((a, b) => a - b);
                }

                this.positions.delete(userId);

                avatar.dispose();
                this.avatars.delete(userId);

                if (window.__updateClickableObjects) {
                    setTimeout(() => window.__updateClickableObjects(), 100);
                }

                if (cameraController) {
                    cameraController.updateBounds();

                    // If 1 avatar remains - center on it
                    if (this.getAvatarCount() === 1) {
                        const remainingAvatar = this.getAvatars()[0];
                        if (remainingAvatar) {
                            cameraController.targetX = remainingAvatar.xPosition;
                        }
                    }
                }

                return true;
            }

            getAvatarCount() { return this.avatars.size; }
            getAvatar(userId) { return this.avatars.get(userId); }
            getAvatars() { return Array.from(this.avatars.values()); }

            clearAll() {
                for (const avatar of this.avatars.values()) avatar.dispose();
                this.avatars.clear();
                this.positions.clear();
                this.availableSlots = [];
                for (let i = 0; i < 50; i++) {
                    this.availableSlots.push(i);
                }
            }

            updateAvatars(deltaTime) {
                for (const avatar of this.avatars.values()) {
                    if (avatar && typeof avatar.update === 'function') {
                        avatar.update(deltaTime);
                    }
                }
            }

            playAvatarAnimation(userId, animationName = 'idle', loop = true) {
                const avatar = this.avatars.get(userId);
                return avatar ? avatar.playAnimation(animationName, loop) : false;
            }
        }

        class CameraController {
            constructor(camera) {
                this.camera = camera;
                this.targetX = 0;
                this.isDragging = false;
                this.startX = 0;
                this.currentX = 0;
                this.initialized = false;
                this.scrollVelocity = 0;
                this.lastDragTime = 0;

                // Scroll boundaries
                this.minX = -CONFIG.SLOT_SPACING * 2; // By default
                this.maxX = CONFIG.SLOT_SPACING * 2;

                this.setupCamera();
                this.setupEventListeners();
            }

            updateBounds() {
                if (!avatarManager) return;

                const avatarCount = avatarManager.getAvatarCount();

                if (avatarCount <= 1) {
                    // If 1 avatar - center on it, scrolling disabled
                    const avatar = avatarManager.getAvatars()[0];
                    if (avatar) {
                        this.minX = avatar.xPosition;
                        this.maxX = avatar.xPosition;
                        this.targetX = avatar.xPosition;
                    }
                } else {
                    // Find extreme avatar positions
                    let minAvatarX = Infinity;
                    let maxAvatarX = -Infinity;

                    for (const avatar of avatarManager.getAvatars()) {
                        if (avatar.xPosition < minAvatarX) minAvatarX = avatar.xPosition;
                        if (avatar.xPosition > maxAvatarX) maxAvatarX = avatar.xPosition;
                    }

                    // Add small margins at edges (half of visible area)
                    const visibleWidth = (this.camera.right - this.camera.left) / 2;
                    this.minX = minAvatarX - visibleWidth / 2;
                    this.maxX = maxAvatarX + visibleWidth / 2;

                    // If avatars fit on screen - center everything
                    if (this.maxX - this.minX < visibleWidth) {
                        const center = (minAvatarX + maxAvatarX) / 2;
                        this.minX = center - visibleWidth / 2;
                        this.maxX = center + visibleWidth / 2;
                    }
                }

                console.log(`Bounds updated: ${this.minX.toFixed(2)} to ${this.maxX.toFixed(2)}, count: ${avatarCount}`);
            }

            setupCamera() {
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 4.0; // Slightly increased to see more

                this.camera.left = -frustumSize * aspect / 2;
                this.camera.right = frustumSize * aspect / 2;
                this.camera.top = frustumSize / 2;
                this.camera.bottom = -frustumSize / 2;
                this.camera.near = 0.1;
                this.camera.far = 1000;
                this.camera.updateProjectionMatrix();

                this.camera.position.set(0, 1.1, CONFIG.CAMERA_DISTANCE);
                this.camera.lookAt(0, 1.1, 0);
            }

            setupEventListeners() {
                const canvas = document.getElementById('renderCanvas');
                canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                canvas.addEventListener('mouseleave', this.onMouseUp.bind(this));
                canvas.addEventListener('touchstart', this.onTouchStart.bind(this), { passive: false });
                canvas.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: false });
                canvas.addEventListener('touchend', this.onTouchEnd.bind(this));
                window.addEventListener('resize', this.onWindowResize.bind(this));
            }

            onMouseDown(event) {
                event.preventDefault();
                this.isDragging = true;
                this.startX = event.clientX;
                this.currentX = this.camera.position.x;
                this.lastDragTime = Date.now();
                this.scrollVelocity = 0;
            }

            onMouseMove(event) {
                if (!this.isDragging) return;
                event.preventDefault();

                const deltaX = event.clientX - this.startX;
                const now = Date.now();
                const dt = now - this.lastDragTime;

                if (dt > 0) {
                    this.scrollVelocity = (deltaX / dt) * 0.5;
                }

                // Calculate new position
                let newTargetX = this.currentX - deltaX * CONFIG.SCROLL_SENSITIVITY;

                // Limit by boundaries
                newTargetX = Math.max(this.minX, Math.min(this.maxX, newTargetX));

                this.targetX = newTargetX;
                this.updateCameraPosition();
                this.lastDragTime = now;
            }

            onMouseUp() {
                if (!this.isDragging) return;
                this.isDragging = false;

                // Check if need to center on nearest avatar
                if (avatarManager && avatarManager.getAvatarCount() > 0) {
                    this.snapToNearestAvatar();
                } else {
                    this.snapToNearestSlot();
                }
            }

            startInertia() {
                const inertia = () => {
                    if (this.isDragging) return;

                    this.scrollVelocity *= 0.95;

                    if (Math.abs(this.scrollVelocity) < 0.01) {
                        this.snapToNearestAvatar();
                        return;
                    }

                    this.targetX += this.scrollVelocity * 0.5;

                    // Limit by boundaries
                    this.targetX = Math.max(this.minX, Math.min(this.maxX, this.targetX));

                    this.updateCameraPosition();
                    requestAnimationFrame(inertia);
                };

                requestAnimationFrame(inertia);
            }

            onTouchStart(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    this.isDragging = true;
                    this.startX = event.touches[0].clientX;
                    this.currentX = this.camera.position.x;
                    this.lastDragTime = Date.now();
                    this.scrollVelocity = 0;
                }
            }

            onTouchMove(event) {
                if (!this.isDragging || event.touches.length !== 1) return;
                event.preventDefault();

                const deltaX = event.touches[0].clientX - this.startX;
                const now = Date.now();
                const dt = now - this.lastDragTime;

                if (dt > 0) {
                    this.scrollVelocity = (deltaX / dt) * 0.5;
                }

                let newTargetX = this.currentX - deltaX * CONFIG.SCROLL_SENSITIVITY;
                newTargetX = Math.max(this.minX, Math.min(this.maxX, newTargetX));

                this.targetX = newTargetX;
                this.updateCameraPosition();
                this.lastDragTime = now;
            }

            onTouchEnd() {
                this.isDragging = false;

                if (Math.abs(this.scrollVelocity) > 0.1) {
                    this.startInertia();
                } else {
                    this.snapToNearestAvatar();
                }
            }

            onWindowResize() {
                this.setupCamera();
                if (renderer) {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            updateCameraPosition() {
                const lerpFactor = this.isDragging ? 0.3 : 0.1;
                const dx = this.targetX - this.camera.position.x;
                this.camera.position.x += dx * lerpFactor;
            }

            snapToNearestSlot() {
                // Center on nearest slot position
                const slotNumber = Math.round(this.camera.position.x / CONFIG.SLOT_SPACING);
                const clampedSlot = Math.max(-24, Math.min(24, slotNumber));
                this.targetX = clampedSlot * CONFIG.SLOT_SPACING;
            }

            snapToNearestAvatar() {
                if (!avatarManager) return;

                const currentX = this.camera.position.x;
                let nearestAvatar = null;
                let minDistance = Infinity;

                // Find nearest avatar
                for (const avatar of avatarManager.getAvatars()) {
                    const distance = Math.abs(avatar.xPosition - currentX);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestAvatar = avatar;
                    }
                }

                if (nearestAvatar) {
                    // Center on nearest avatar
                    this.targetX = nearestAvatar.xPosition;
                }
            }

            centerOnAvatar(userId, duration = 500) {
                if (!avatarManager) return false;
                
                const avatar = avatarManager.getAvatar(userId);
                if (!avatar) return false;
                
                const targetX = avatar.xPosition;
                const startX = this.camera.position.x;
                const startTime = Date.now();
                
                // Animate camera to target position
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    // Ease out cubic: 1 - (1-p)^3
                    const eased = 1 - Math.pow(1 - progress, 3);
                    
                    this.targetX = startX + (targetX - startX) * eased;
                    this.updateCameraPosition();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.targetX = targetX; // Ensure exact final position
                    }
                };
                
                animate();
                return true;
            }

            update() {
                if (!this.isDragging) {
                    this.updateCameraPosition();
                }

                // On first entry or when avatar count changes
                if (!this.initialized && window.currentUserId) {
                    const myAvatar = avatarManager?.getAvatar(window.currentUserId);
                    if (myAvatar?.xPosition !== undefined) {
                        this.updateBounds(); // Update bounds
                        this.targetX = myAvatar.xPosition;
                        this.initialized = true;
                        console.log('Camera centered on current user');
                    }
                }
            }
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);

            camera = new THREE.OrthographicCamera();

            const canvas = document.getElementById('renderCanvas');
            
            // WebGL context attributes optimized for mobile devices
            const contextAttributes = {
                alpha: false,
                antialias: false, // Disable antialiasing for better compatibility
                depth: true,
                stencil: false,
                preserveDrawingBuffer: false,
                powerPreference: "high-performance",
                failIfMajorPerformanceCaveat: false
            };
            
            renderer = new THREE.WebGLRenderer({
                canvas,
                ...contextAttributes
            });

            // Check for WebGL extensions and log warnings
            const gl = renderer.getContext();
            const extensions = {
                OES_texture_float: gl.getExtension('OES_texture_float'),
                OES_texture_float_linear: gl.getExtension('OES_texture_float_linear'),
                OES_texture_half_float: gl.getExtension('OES_texture_half_float'),
                OES_texture_half_float_linear: gl.getExtension('OES_texture_half_float_linear')
            };
            
            console.log('WebGL Extensions:', {
                OES_texture_float: !!extensions.OES_texture_float,
                OES_texture_float_linear: !!extensions.OES_texture_float_linear,
                OES_texture_half_float: !!extensions.OES_texture_half_float,
                OES_texture_half_float_linear: !!extensions.OES_texture_half_float_linear
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            // Limit pixel ratio to 1.5 for better performance on mobile
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            
            // Configure shadow maps for mobile compatibility (only if supported)
            if (renderer.shadowMap) {
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                console.log('✅ Shadow maps enabled');
            } else {
                console.warn('⚠️ Shadow maps not supported on this device');
            }

            setupLighting();
            avatarManager = new AvatarManager();
            cameraController = new CameraController(camera);
            setupRaycaster();

            setTimeout(() => {
                isInitialized = true;
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) overlay.style.display = 'none';
            }, 1000);
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();

            const deltaTime = clock.getDelta();

            if (avatarManager) avatarManager.updateAvatars(deltaTime);
            if (cameraController) cameraController.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        let lastClickTime = 0;
        const clickDelay = 300;

        function setupRaycaster() {
            const canvas = document.getElementById('renderCanvas');

            window.__updateClickableObjects = function () {
                if (!scene) return;

                window.clickableObjects = [];
                scene.traverse(obj => {
                    if (obj.userData && obj.userData.isCollider === true) {
                        window.clickableObjects.push(obj);
                    }
                });
            };

            window.clickableObjects = [];

            setTimeout(() => {
                if (scene) {
                    window.__updateClickableObjects();
                }
            }, 1000);

            if (updateInterval) {
                clearInterval(updateInterval);
            }

            updateInterval = setInterval(() => {
                if (scene) {
                    window.__updateClickableObjects();
                }
            }, 3000);

            window.handleClick = function (event) {
                const currentTime = Date.now();
                if (currentTime - lastClickTime < clickDelay) return;
                lastClickTime = currentTime;

                const rect = canvas.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                camera.updateMatrixWorld(true);

                const intersects = raycaster.intersectObjects(window.clickableObjects, true);

                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    while (obj && !obj.userData?.avatarId) {
                        obj = obj.parent;
                    }

                    if (obj?.userData?.avatarId) {

                        try {
                            if (window.hubblyBridge && typeof window.hubblyBridge.postMessage === 'function') {
                                window.hubblyBridge.postMessage(JSON.stringify({
                                    type: 'avatar_clicked',
                                    userId: obj.userData.avatarId
                                }));
                            }
                        } catch (e) {
                            console.error('Bridge communication failed:', e);
                        }
                    }
                }
            };

            canvas.addEventListener('click', window.handleClick);
            canvas.addEventListener('touchend', (event) => {
                if (event.touches.length === 0) {
                    const touch = event.changedTouches[0];
                    const mouseEvent = new MouseEvent('click', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    window.handleClick(mouseEvent);
                }
            });
        }

        window.hubbly3d = {
            isReady: () => isInitialized && !!scene,

            addAvatar: function (userId, nickname, gender, isCurrentUser = false) {
                if (!isInitialized || !avatarManager) return false;

                if (isCurrentUser && window.currentUserId === userId) {
                    return true;
                }

                if (isCurrentUser) {
                    window.currentUserId = userId;
                }

                return avatarManager.addAvatar(userId, nickname, gender, isCurrentUser);
            },

            removeAvatar: function (userId) {
                return avatarManager?.removeAvatar(userId) || false;
            },

            clearAvatars: function () {
                avatarManager?.clearAll();
                return true;
            },

            getAvatarCount: () => avatarManager?.getAvatarCount() || 0,

            getAvatars: () => avatarManager?.getAvatars().map(a => ({
                userId: a.userId,
                nickname: a.nickname,
                gender: a.gender,
                isLoaded: a.isLoaded
            })) || [],

            getAvatarList: () => {
                if (!avatarManager) return [];
                return avatarManager.getAvatars()
                    .map(a => ({
                        userId: a.userId,
                        nickname: a.nickname,
                        gender: a.gender,
                        slotIndex: a.slotIndex,
                        xPosition: a.xPosition,
                        isLoaded: a.isLoaded
                    }))
                    .sort((a, b) => a.slotIndex - b.slotIndex);
            },

            // Determines which avatar is closest to the center of the camera view
            getAvatarAtCenter: function () {
                if (!avatarManager || !cameraController) return null;
                
                const avatars = avatarManager.getAvatars();
                if (avatars.length === 0) return null;
                
                // Find avatar with xPosition closest to camera.position.x
                let nearestAvatar = null;
                let minDistance = Infinity;
                
                for (const avatar of avatars) {
                    const distance = Math.abs(avatar.xPosition - camera.position.x);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestAvatar = avatar;
                    }
                }
                
                if (nearestAvatar) {
                    return {
                        userId: nearestAvatar.userId,
                        nickname: nearestAvatar.nickname,
                        gender: nearestAvatar.gender,
                        slotIndex: nearestAvatar.slotIndex,
                        xPosition: nearestAvatar.xPosition,
                        isLoaded: nearestAvatar.isLoaded
                    };
                }
                
                return null;
            },

            // Navigate to next/previous avatar based on current camera position
            navigateToAdjacentAvatar: function (direction) {
                if (!avatarManager || !cameraController) return null;
                
                const avatars = avatarManager.getAvatars();
                if (avatars.length <= 1) return null;
                
                // Get current center avatar
                const currentCenter = this.getAvatarAtCenter();
                if (!currentCenter) return null;
                
                // Find avatars in the specified direction
                const sortedAvatars = [...avatars].sort((a, b) => a.slotIndex - b.slotIndex);
                const currentIndex = sortedAvatars.findIndex(a => a.userId === currentCenter.userId);
                
                if (currentIndex === -1) return null;
                
                let targetIndex;
                if (direction === 'next') {
                    // Move to right (higher slot index)
                    targetIndex = currentIndex + 1;
                    if (targetIndex >= sortedAvatars.length) targetIndex = sortedAvatars.length - 1;
                } else {
                    // Move to left (lower slot index)
                    targetIndex = currentIndex - 1;
                    if (targetIndex < 0) targetIndex = 0;
                }
                
                const targetAvatar = sortedAvatars[targetIndex];
                if (targetAvatar && targetAvatar.userId !== currentCenter.userId) {
                    this.centerOnAvatar(targetAvatar.userId);
                    return {
                        userId: targetAvatar.userId,
                        nickname: targetAvatar.nickname,
                        gender: targetAvatar.gender,
                        slotIndex: targetAvatar.slotIndex,
                        xPosition: targetAvatar.xPosition,
                        isLoaded: targetAvatar.isLoaded
                    };
                }
                
                return null;
            },

            centerOnAvatar: function (userId) {
                if (!cameraController) return false;
                return cameraController.centerOnAvatar(userId);
            },

            playAnimation: (userId, animationName = 'idle', loop = true) => {
                let animName = animationName;
                if (animationName === 'clap' || animationName === 'clapping') {
                    animName = 'clap';
                }
                return avatarManager?.playAvatarAnimation(userId, animName, loop) || false;
            },

            // Hold navigation with 200ms interval
            _holdTimer: null,
            _holdDirection: null,
            _isHolding: false,
            
            startHoldNavigation: function (direction) {
                if (this._isHolding) return;
                
                this._isHolding = true;
                this._holdDirection = direction;
                
                // Execute first navigation immediately
                const result = this.navigateToAdjacentAvatar(direction);
                
                // Then set up repeat every 200ms
                this._holdTimer = setInterval(() => {
                    const res = this.navigateToAdjacentAvatar(direction);
                    if (!res) {
                        // No more avatars in that direction, stop holding
                        this.stopHoldNavigation();
                    }
                }, 200);
                
                return result;
            },
            
            stopHoldNavigation: function () {
                if (this._holdTimer) {
                    clearInterval(this._holdTimer);
                    this._holdTimer = null;
                }
                this._isHolding = false;
                this._holdDirection = null;
            },

            cleanup: function () {
                if (updateInterval) {
                    clearInterval(updateInterval);
                    updateInterval = null;
                }
                this.stopHoldNavigation();
                avatarManager?.clearAll();
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            if (!(() => {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext &&
                        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch { return false; }
            })()) {
                document.getElementById('loadingOverlay').innerHTML =
                    '<div style="color: #ef4444;">WebGL Not Supported</div>';
                return;
            }

            initThreeJS();
            animate();
        });

        // Handle WebGL context loss
        const canvas = document.getElementById('renderCanvas');
        canvas.addEventListener('webglcontextlost', (event) => {
            event.preventDefault();
            console.log('WebGL context lost');
            setTimeout(() => {
                if (renderer) {
                    renderer.forceContextLoss();
                    renderer.dispose();
                }
                initThreeJS();
            }, 100);
        });
    </script>
</body>
</html>